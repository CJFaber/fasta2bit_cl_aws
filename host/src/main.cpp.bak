// Copyright (C) 2013-2015 Altera Corporation, San Jose, California, USA. All rights reserved.
// Permission is hereby granted, free of charge, to any person obtaining a copy of this
// software and associated documentation files (the "Software"), to deal in the Software
// without restriction, including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to
// whom the Software is furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
// 
// This agreement shall be governed in all respects by the laws of the State of California and
// by the laws of the United States of America.

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <omp.h>

// ACL specific includes
#include "CL/opencl.h"
// /tools/x86_64/intelharpv2/opencl/altera/16.0/hld/host/include/CL


//#include "ACLHostUtils.h"
#include "AOCLUtils/aocl_utils.h"

//UserIncludes
#include "../inc/fix.h"
#include "../inc/utils.h"

#define STR_SIZE 30
//#define OUTP_DST "./" 
//#define INP_DST


using namespace aocl_utils;
static const char *kernel_name = "fixPt16_toFloat";

FILE *outp;
FILE *inp;

// ACL runtime configuration
static cl_platform_id platform;
static cl_device_id device;
static cl_context context;
static cl_command_queue queue;
static cl_kernel kernel;
static cl_event kernel_event;
static cl_program program;
static cl_int status;

// input and output vectors
//static unsigned *hdatain, *hdataout;

static short* fixed_src;
static float*   float_dst;


static void dump_error(const char *str, cl_int status) {
  printf("%s\n", str);
  printf("Error code: %d\n", status);
}

// free the resources allocated during initialization
static void freeResources() {

  if(kernel){ 
    clReleaseKernel(kernel);
    //printf("freed kernel\n"); 
  }
  if(program){
    clReleaseProgram(program);
    //printf("freed program\n");
  }
  if(queue){
    clReleaseCommandQueue(queue);
    //printf("freed queue\n");
  }
  if(fixed_src){
   clSVMFreeAltera(context,fixed_src);
   //printf("freed fixed_src\n");
  }
  if(float_dst){
   clSVMFreeAltera(context,float_dst);
   //printf("freed float_dst\n");
  }
  if(context){
   clReleaseContext(context);
   //printf("freed context\n");
  } 
//  if(kernel_event)
//    clReleaseEvent(kernel_event);
}


void cleanup() {
	//It DOES NOTHING!
	//Have to declare it due to altera Opencl
}



int main(int argc, char *argv[]) {
  long int inp_size;
  //long unsigned int i;
  size_t bufLen;  
  int QVal;
  cl_uint num_platforms;
  cl_uint num_devices;
  double wtime_kernel;
  double wtime_setup;   
  double wtime_prog; 
  // manageral  
  // Parse arguments
  if (!(argc >= 3 )){
	printf("\tUsage:  Interperates a binary file as fixed point values whoes Q\n");
	printf("\t\tvalue is defined on input. The fixed point values are then\n");
	printf("\t\twritten to an output binary file as floating point numbers\n");
	printf("Example: ./FixToFloat input.bin Q\n\n");
    	return(0);
  }
  QVal = (int)atoi(argv[2]);
  if(QVal <= 0 || QVal >= 32){ 
	printf("ERROR: Qvalue Invalid\n"); 
	return -1;
  }
  inp = fopen(argv[1], "rb");
  if(!inp){
	printf("ERROR: FILE NOT FOUND\n"); 
	return -1;
  }
  
  wtime_setup = omp_get_wtime();
  // get the platform ID
  status = clGetPlatformIDs(1, &platform, &num_platforms);
  if(status != CL_SUCCESS) {
    dump_error("Failed clGetPlatformIDs.", status);
    freeResources();
    return 1;
  }
  
  if(num_platforms != 1) {
    printf("Found %d platforms!\n", num_platforms);
    freeResources();
    return 1;
  }

  // get the device ID
  status = clGetDeviceIDs(platform, CL_DEVICE_TYPE_ALL, 1, &device, &num_devices);
  
  if(status != CL_SUCCESS) {
    dump_error("Failed clGetDeviceIDs.", status);
    freeResources();
    return 1;
  }
  
  if(num_devices != 1) {
    printf("Found %d devices!\n", num_devices);
    freeResources();
    return 1;
  }

  // create a context
  context = clCreateContext(0, 1, &device, NULL, NULL, &status);
  if(status != CL_SUCCESS) {
    dump_error("Failed clCreateContext.", status);
    freeResources();
    return 1;
  }
    
//////////////////////////////////////////////////////
// Alocate buffer for fixed float values
// fixed_src (SVM short buffer)

  //printf("Creating alocate buffer for fixed values\n");
  if (fseek(inp, 0L, SEEK_END) != 0){
    printf("Something has gone wrong.\n");
    return -1;
  }
  inp_size = ftell(inp);
  if ((inp_size) == -1){
    printf("Something has gone wrong.\n");
    return -1;
  }
  rewind(inp);
  fixed_src = (short*)clSVMAllocAltera(context, CL_MEM_READ_ONLY, (sizeof(short)*((inp_size) + 1)), 0);
  if(fixed_src ==  NULL){
    printf("Error on clSVMAlloc!");
    return -1;
  }
  bufLen = fread(fixed_src, sizeof(short), inp_size, inp);
  if (ferror(inp)){
    printf("Something has gone wrong.\n");
    return -1;
  }
  printFixFile_16(fixed_src, bufLen, QVal, 0);

//////////////////////////////////////////////////////
// Allocate buffer for float values
// float_dst (un-initalized) 
  //printf("Creating alocate buffer for float values\n");
  float_dst = (float *)clSVMAllocAltera(context, CL_MEM_WRITE_ONLY, bufLen, 0);
  if(!fixed_src || !float_dst) {
    dump_error("Failed to allocate buffers.", status);
    freeResources();
    return 1;	
  
  }

//////////////////////////////////////////////////////
// create a command queue

  //printf("Creating command queue\n");
  queue = clCreateCommandQueue(context, device, CL_QUEUE_PROFILING_ENABLE, &status);
  if(status != CL_SUCCESS) {
    dump_error("Failed clCreateCommandQueue.", status);
    freeResources();
    return 1;
  }
  

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Create the program from binary works for both emulation and implementation 
  

  wtime_prog = omp_get_wtime();
  cl_int kernel_status;


  size_t binsize = 0;
  unsigned char * binary_file = loadBinaryFile("bin/fixtofloat.aocx", &binsize);
  
  if(!binary_file) {
    dump_error("Failed loadBinaryFile.", status);
    freeResources();
    return 1;
  }
  
  program = clCreateProgramWithBinary(context, 1, &device, &binsize, (const unsigned char**)&binary_file, &kernel_status, &status);
  if(status != CL_SUCCESS) {
    dump_error("Failed clCreateProgramWithBinary.", status);
    freeResources();
    return 1;
  }
  delete [] binary_file;
  
  status = clBuildProgram(program, 0, NULL, "", NULL, NULL);
  if(status != CL_SUCCESS) {
    dump_error("Failed clBuildProgram.", status);
    freeResources();
    return 1;
  }
  wtime_prog = omp_get_wtime() - wtime_prog;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Create the fixed to float kernel
//

  //printf("Creating the fix to float kernel\n");
  //{
    // create the kernel
    kernel = clCreateKernel(program, kernel_name, &status);
    
    if(status != CL_SUCCESS) {
      dump_error("Failed clCreateKernel.", status);
      freeResources();
      return 1;
    }

    // set the arguments
    status = clSetKernelArgSVMPointerAltera(kernel, 0, (void*)fixed_src);
    if(status != CL_SUCCESS) {
      dump_error("Failed set arg 0.", status);
      return 1;
    }
    status = clSetKernelArgSVMPointerAltera(kernel, 1, (void*)float_dst);
    if(status != CL_SUCCESS) {
      dump_error("Failed Set arg 1.", status);
      freeResources();
      return 1;
    }

    cl_int arg_2 = QVal;
    status = clSetKernelArg(kernel, 2, sizeof(cl_int), &(arg_2));
    if(status != CL_SUCCESS) {
      dump_error("Failed Set arg 2.", status);
      freeResources();
      return 1;
    }

    cl_ulong arg_3 = bufLen;
    status = clSetKernelArg(kernel, 3, sizeof(cl_ulong), &(arg_3));
    if(status != CL_SUCCESS) {
	dump_error("Failed Set arg 3.", status);
        freeResources();
	return 1;
    }

//////////////////////////////////////////////////////////////////////////////////////////////////
// Map the buffers
//
    //printf("Mapping the SVM buffers\n");
    status = clEnqueueSVMMap(queue, CL_TRUE, CL_MAP_READ, (void *)fixed_src, bufLen, 0, NULL, NULL);    
    if(status != CL_SUCCESS) {
      dump_error("Failed clEnqueueSVMMap", status);
      freeResources();
      return 1;
    }
    
    status = clEnqueueSVMMap(queue, CL_TRUE, CL_MAP_WRITE, (void *)float_dst, bufLen, 0, NULL, NULL); 
    if(status != CL_SUCCESS) {
      dump_error("Failed clEnqueueSVMMap", status);
      freeResources();
      return 1;
    }
    
//////////////////////////////////////////////////////////////////////////////////////////////////
// Run the kernel
    //printf("Run the kernel\n");
    wtime_kernel = omp_get_wtime();
    // Run the Queue
    //status = clEnqueueNDRangeKernel(queue, kernel, 1, NULL, &bufLen, NULL, 0, NULL, &kernel_event);
    status = clEnqueueTask(queue, kernel, 0, NULL, NULL);
    if (status != CL_SUCCESS) {
      dump_error("Failed to launch kernel.", status);
      freeResources();
      return 1;
    }
    //Wait until done (sync)
    clFinish(queue);
    //printf("finished!\n");
    wtime_kernel = omp_get_wtime() - wtime_kernel;

/////////////////////////////////////////////////////////////////////////////////////////////////
// Kernel finished, unmaped buffers
    //printf("Unmap the buffers\n");
    status = clEnqueueSVMUnmap(queue, (void *)fixed_src, 0, NULL, NULL); 
    if(status != CL_SUCCESS) {
      dump_error("Failed clEnqueueSVMUnmap", status);
      freeResources();
      return 1;
    }
    status = clEnqueueSVMUnmap(queue, (void *)float_dst, 0, NULL, NULL); 
    if(status != CL_SUCCESS) {
      dump_error("Failed clEnqueueSVMUnmap", status);
      freeResources();
      return 1;
    }	
  //}
/////////////////////////////////////////////////////////////////////////////////////////////////
// Verification - Not necessary for running

  //printf("Writing data and freeing memory\n");
  printFixFile_16(fixed_src, bufLen, QVal, 0);
  printFloatFiles(float_dst, bufLen, 0);
  //fclose(outp);
  fclose(inp);
  freeResources();
  wtime_setup = omp_get_wtime() - wtime_setup;
  printf("%s:",argv[1]);
  printf("  %.6f, %.6f, %.6f\n", wtime_kernel, wtime_setup, wtime_prog); 


  return 0;
}



